% ********************************* HEADERS ***********************************
\documentclass{article}
\usepackage[top=.75in, bottom=.75in, left=.50in,right=.50in]{geometry}
\usepackage{fancyhdr}
\usepackage{titling}
\pagestyle{fancy}
\lhead{EECS 281 - Data Structures and Algorithms}
\rhead{\thepage}
\usepackage{color}
\usepackage{graphicx}
\newcommand{\heart}{\ensuremath\heartsuit}
\usepackage{listings}
\lstset{
  % language=C++,
  showstringspaces=false,
  basicstyle={\small\ttfamily},
  numberstyle=\tiny\color{gray},
  keywordstyle=\color{blue},
  commentstyle=\color{dkgreen},
  stringstyle=\color{dkgreen},
}
\usepackage[colorlinks,urlcolor={blue}]{hyperref}
%\setlength{\parskip}{1em}
\usepackage{parskip}
\usepackage{indentfirst}
\setlength{\droptitle}{-4em}
% \usepackage{concmath}
% \usepackage[T1]{fontenc}
\renewcommand{\theenumi}{\Alph{enumi}}
% ********************************* HEADERS ***********************************
\pagenumbering{gobble}
\begin{document}
\title{\textbf{EECS 281 Lab 8 - Fragmented Data Structures (part 2)}}
\author{Due Tuesday, March 15th, 2017 at 11:59pm}
\date{}
\maketitle
\fancypagestyle{firststyle}
{
   \fancyfoot[L]{Written by Aaryaman Sagar for EECS 281 @ The University of
                 Michigan - Ann Arbor}
   \pagestyle{empty}
}
\thispagestyle{firststyle}

In this lab you will be using the transparent linked list from last lab to
finish writing a memory allocator to allocate memory on the heap!

\section{An untyped memory allocator}
You will be using the transparent list class you wrote in the previous lab to
write an untyped memory allocator very much like the C \texttt{malloc()}
function to allocate memory on the heap.

Memory allocators including the C++ \texttt{new} operator get memory on the
heap through function calls to the operating system.  Your allocator will be
keeping track of the memory available from all previous requests to the
operating system in a fragmented linked list.

A fragmented data structure is one that comprises of elements stored
discontinuously and possibly of different sizes.  The below two pictures
illustrate the difference between fragmented and non-fragmented data
structures.

\begin{figure}[!htb]
\centering
\includegraphics[height=2cm]{fragmented_memory}
\caption{Fragemented memory}
\end{figure}

\begin{figure}[!htb]
\centering
\includegraphics[height=2cm]{non_fragmented_memory}
\caption{Non fragemented memory}
\end{figure}

A memory request is served by returning a block of memory to the user as a
\texttt{void*} pointer.  This allocated memory that is large enough to store
the amount of data the user has asked for.  The allocator keeps track of the
memory segments and how large each segment is by storing a header with the
size information just before the actual usable memory.  The memory map looks
like this, with the black rectangles denoting the headers and the grey the
actual memory blocks.

\begin{figure}[!htb]
\centering
\includegraphics[height=2cm]{memory_storage}
\caption{Memory storage}
\end{figure}

In the above image, the pointer that will be returned to the user for usage
will start at the starting location of the grey area, and the header right
before that will contain the length of that grey area.  This way the allocator
knows how much memory each allocated block points to, so that if the
\texttt{free()} function is called on that memory, it can be put back into the
linked list of headers.

The linked list of headers will resemble the list shown in figure 4 below,
with each header pointing to the next header in the logically increasing order
or addresses (for example here the first header on the left is at a lower
location in memory as compared to the second and the third while the second
one is at a lower location in memory as compared to the third)

\begin{figure}[!htb]
\centering
\includegraphics[height=3cm]{linked_list_headers}
\caption{Linked list headers}
\end{figure}

When the user asks for memory, the block with the right amount of memory will
be taken out of the linked list and returned to the user, so for example if
the user asked for a really large portion of memory then the allocator can
return a portion of the second segment to the user.  Subsequently the free
list will be updated to look like so, with the user using the memory in red.

\begin{figure}[!htb]
\centering
\includegraphics[height=3cm]{after_allocation}
\caption{After an allocation}
\end{figure}

When a user program wants to deallocate the same memory (like a call to
delete) they have to pass the pointer that was allocated via the
\texttt{malloc()} call to \texttt{free()}.  The free function is supposed to
backtrack from the pointer the user passed (which will be pointing to the
beginning of the allocated segment, i.e.  the grey area) back to the header
and put the header back into the linked list.  This can be done via a simple
pointer cast to the header type and decrement by one.  Analagously if you
wanted to get the location of an object of type \texttt{int} right before a
pointer \texttt{ptr}, you would do

\begin{lstlisting}
int* pointer_right_before = static_cast<int*>(ptr) - 1;
\end{lstlisting}

The free function will coalesce memory blocks if they are right by each other
into one bigger block to save on memory used to store headers.  This can be
done through a call to \texttt{coalesce()}.  If the two headers can be
coalesced then the function will coalesce them and return a pointer to the
coalesced header, the function returns a \texttt{nullptr} to denote failure.

\begin{figure}[!htb]
\centering
\includegraphics[height=2.3cm]{before_coalescing}
\caption{After a deallocation (before coalescing)}
\end{figure}

\begin{figure}[!htb]
\centering
\includegraphics[height=2.3cm]{after_deallocation}
\caption{After a deallocationi (after coalescing)}
\end{figure}

\newpage
\subsection{Useful C++ Concepts}

\end{document}


